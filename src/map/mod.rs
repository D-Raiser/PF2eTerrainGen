use once_cell::sync::OnceCell;
use rand::rngs::ThreadRng;
use rand::Rng;
use sdl2::pixels::Color;
use std::slice::Iter;

pub struct MapState {
    pub map: Map,
    pub map_size: (i16, i16),
    pub iterations: u16,
}

impl MapState {
    pub fn new(width: i16, height: i16, iterations: u16) -> Result<MapState, String> {
        let map = Map::generate((width, height), iterations)?;
        Ok(MapState {
            map,
            map_size: (width, height),
            iterations,
        })
    }
}

pub struct Map {
    pub tiles: Vec<Vec<Hex>>,
}

#[derive(Clone)]
pub struct Hex {
    pub hex_type: HexType,
}

impl Hex {
    const NONE_HEX: Hex = Hex {
        hex_type: HexType::NONE,
    };
}

#[derive(Copy, Clone, PartialEq)]
pub struct HexType {
    pub color: Color,
    // chance to generate a tile of this type in percent
    base_chance: u16,
    // chance in percent to transform into this `HexType` based on the tile's current `HexType` when
    // smoothing the map
    transform_chance: fn(HexType) -> u16,
}

impl HexType {
    const NONE: HexType = HexType {
        color: Color::RGB(40, 40, 40),
        // never generate this
        base_chance: 0,
        transform_chance: |_| 0,
    };

    // Common Environments
    const AQUATIC: HexType = HexType {
        color: Color::RGB(0, 130, 220),
        base_chance: 70,
        transform_chance: |_| 0,
    };
    const ARCTIC: HexType = HexType {
        color: Color::RGB(145, 230, 230),
        base_chance: 0,
        transform_chance: |t| if t == HexType::AQUATIC { 5 } else { 0 },
    };
    const DESERT: HexType = HexType {
        color: Color::RGB(230, 230, 30),
        base_chance: 4,
        transform_chance: |t| if t == HexType::PLAINS { 5 } else { 0 },
    };
    const FOREST: HexType = HexType {
        color: Color::RGB(10, 105, 15),
        base_chance: 12,
        transform_chance: |_t| 0,
    };
    const MOUNTAIN: HexType = HexType {
        color: Color::RGB(88, 97, 96),
        base_chance: 6,
        transform_chance: |_| 0,
    };
    const PLAINS: HexType = HexType {
        color: Color::RGB(0, 205, 12),
        base_chance: 8,
        transform_chance: |_| 0,
    };
    // TODO: Urban ?
    const SWAMP: HexType = HexType {
        color: Color::RGB(50, 80, 10),
        base_chance: 0,
        transform_chance: |t| {
            if t == HexType::FOREST || t == HexType::PLAINS {
                5
            } else {
                0
            }
        },
    };

    // Extreme Environments
    const AERIAL: HexType = HexType {
        color: Color::RGB(202, 216, 214),
        base_chance: 0,
        transform_chance: |t| if t == HexType::MOUNTAIN { 3 } else { 0 },
    };
    const GLACIER: HexType = HexType {
        color: Color::RGB(216, 255, 255),
        base_chance: 0,
        // requires at least 2 smoothing iterations, since `ARCTIC` isn't generated by default
        transform_chance: |t| if t == HexType::ARCTIC { 40 } else { 0 },
    };
    const VOLCANIC: HexType = HexType {
        color: Color::RGB(154, 5, 3),
        base_chance: 0,
        transform_chance: |t| if t == HexType::MOUNTAIN { 10 } else { 0 },
    };
    // TODO: Undersea?
    // TODO: Underground?

    fn iterator() -> Iter<'static, HexType> {
        static HEX_TYPES: [HexType; 11] = [
            HexType::NONE,
            HexType::AQUATIC,
            HexType::ARCTIC,
            HexType::DESERT,
            HexType::FOREST,
            HexType::MOUNTAIN,
            HexType::PLAINS,
            HexType::SWAMP,
            HexType::AERIAL,
            HexType::GLACIER,
            HexType::VOLCANIC,
        ];
        HEX_TYPES.iter()
    }

    fn transform_chance(hex_type: HexType) -> u16 {
        HexType::iterator()
            .map(|t| HexType::transform_chance(hex_type)) // TODO: Verify; this doesn't feel correct
            .sum()
    }

    fn summed_terrain_base_chance() -> u16 {
        static INSTANCE: OnceCell<u16> = OnceCell::new();
        *INSTANCE.get_or_init(|| HexType::iterator().map(|t| t.base_chance).sum())
    }
}

impl Map {
    pub fn generate(dimensions: (i16, i16), iterations: u16) -> Result<Map, String> {
        let (width, height) = dimensions;
        if height % 2 != 0 || width % 2 != 0 || height < 2 || width < 2 {
            // With uneven numbers the map cannot be tiled infinitely without gaps
            return Err(String::from("Map dimensions must be even positive numbers"));
        }

        let tiles: Vec<Vec<Hex>> = vec![vec![Hex::NONE_HEX; width as usize]; height as usize];
        let mut map = Map { tiles }.populate();

        for _ in 0..iterations {
            map = map.smooth();
        }

        Ok(map)
    }

    fn populate(self) -> Map {
        self.populate_randomly()
    }

    fn populate_randomly(mut self) -> Map {
        let mut rng = rand::thread_rng();
        let max_x = self.tiles.len();
        let max_y = self.tiles[0].len();

        for (y, row) in self.tiles.iter_mut().enumerate() {
            for (x, hex) in row.iter_mut().enumerate() {
                *hex = Map::generate_hex(&mut rng, x, y, max_x, max_y);
            }
        }
        self
    }

    fn smooth(self) -> Map {
        self
    }

    fn generate_hex(
        rng: &mut ThreadRng,
        _x: usize,
        _y: usize,
        _max_x: usize,
        _max_y: usize,
    ) -> Hex {
        //let equator_dist = (max_y / 2).abs_diff(y);
        //let pole_dist = min((0 as usize).abs_diff(y), max_y.abs_diff(y));
        let n = rng.gen_range(0..HexType::summed_terrain_base_chance());
        let (_, hex_type) =
            HexType::iterator().fold((0, HexType::NONE), |(summed_percentage, hex_type), &t| {
                if summed_percentage > n {
                    (summed_percentage, hex_type)
                } else {
                    (summed_percentage + t.base_chance, t)
                }
            });

        Hex { hex_type }
    }
}
