use once_cell::sync::OnceCell;
use rand::rngs::ThreadRng;
use rand::Rng;
use sdl2::pixels::Color;
use std::collections::HashMap;
use std::slice::Iter;

pub struct MapState {
    pub map: Map,
    pub map_size: (i16, i16),
    pub iterations: u16,
}

impl MapState {
    pub fn new(width: i16, height: i16, iterations: u16) -> Result<MapState, String> {
        let map = Map::generate((width, height), iterations)?;
        Ok(MapState {
            map,
            map_size: (width, height),
            iterations,
        })
    }
}

pub struct Map {
    pub tiles: Vec<Vec<Hex>>,
}

#[derive(Clone)]
pub struct Hex {
    pub hex_type: HexType,
}

impl Hex {
    const NONE_HEX: Hex = Hex {
        hex_type: HexType::NONE,
    };
}

#[derive(Copy, Clone, Eq, Hash, PartialEq)]
pub struct HexType {
    pub color: Color,
    // chance to generate a tile of this type in percent
    base_chance: u16,
    // chance in percent to transform into this `HexType` based on the tile's current `HexType` when
    // smoothing the map
    transform_chance: fn(HexType) -> u16,
}

impl HexType {
    const NONE: HexType = HexType {
        color: Color::RGB(40, 40, 40),
        // never generate this
        base_chance: 0,
        transform_chance: |_| 0,
    };

    // Common Environments
    const AQUATIC: HexType = HexType {
        color: Color::RGB(0, 130, 220),
        // starting out with 70% (which could be considered realistic) leads to water
        // spreading even further during smoothing since it's the most prevalent element already
        base_chance: 14,
        transform_chance: |_| 0,
    };
    const ARCTIC: HexType = HexType {
        color: Color::RGB(145, 230, 230),
        base_chance: 0,
        transform_chance: |t| if t == HexType::AQUATIC { 5 } else { 0 },
    };
    const DESERT: HexType = HexType {
        color: Color::RGB(230, 230, 30),
        base_chance: 4,
        transform_chance: |t| if t == HexType::PLAINS { 5 } else { 0 },
    };
    const FOREST: HexType = HexType {
        color: Color::RGB(10, 105, 15),
        base_chance: 12,
        transform_chance: |_t| 0,
    };
    const MOUNTAIN: HexType = HexType {
        color: Color::RGB(88, 97, 96),
        base_chance: 6,
        transform_chance: |_| 0,
    };
    const PLAINS: HexType = HexType {
        color: Color::RGB(0, 205, 12),
        base_chance: 8,
        transform_chance: |_| 0,
    };
    // TODO: Urban ?
    const SWAMP: HexType = HexType {
        color: Color::RGB(50, 80, 10),
        base_chance: 0,
        transform_chance: |t| {
            if t == HexType::FOREST || t == HexType::PLAINS {
                5
            } else {
                0
            }
        },
    };

    // Extreme Environments
    const AERIAL: HexType = HexType {
        color: Color::RGB(202, 216, 214),
        base_chance: 0,
        transform_chance: |t| if t == HexType::MOUNTAIN { 3 } else { 0 },
    };
    const GLACIER: HexType = HexType {
        color: Color::RGB(216, 255, 255),
        base_chance: 0,
        // requires at least 2 smoothing iterations, since `ARCTIC` isn't generated by default
        transform_chance: |t| if t == HexType::ARCTIC { 40 } else { 0 },
    };
    const VOLCANIC: HexType = HexType {
        color: Color::RGB(154, 5, 3),
        base_chance: 0,
        transform_chance: |t| if t == HexType::MOUNTAIN { 10 } else { 0 },
    };
    // TODO: Undersea?
    // TODO: Underground?

    fn iterator() -> Iter<'static, HexType> {
        static HEX_TYPES: [HexType; 11] = [
            HexType::NONE,
            HexType::AQUATIC,
            HexType::ARCTIC,
            HexType::DESERT,
            HexType::FOREST,
            HexType::MOUNTAIN,
            HexType::PLAINS,
            HexType::SWAMP,
            HexType::AERIAL,
            HexType::GLACIER,
            HexType::VOLCANIC,
        ];
        HEX_TYPES.iter()
    }

    fn total_transform_chance(hex_type: HexType) -> u16 {
        HexType::iterator()
            .map(|&t| (t.transform_chance)(hex_type))
            .sum()
    }

    fn summed_terrain_base_chance() -> u16 {
        static INSTANCE: OnceCell<u16> = OnceCell::new();
        *INSTANCE.get_or_init(|| HexType::iterator().map(|t| t.base_chance).sum())
    }
}

impl Map {
    pub fn generate(dimensions: (i16, i16), iterations: u16) -> Result<Map, String> {
        let (width, height) = dimensions;
        if height % 2 != 0 || width % 2 != 0 || height < 2 || width < 2 {
            // With uneven numbers the map cannot be tiled infinitely without gaps
            return Err(String::from("Map dimensions must be even positive numbers"));
        }

        let tiles: Vec<Vec<Hex>> = vec![vec![Hex::NONE_HEX; width as usize]; height as usize];
        let mut map = Map { tiles }.populate();

        for _ in 0..iterations {
            map.smooth();
        }

        Ok(map)
    }

    fn populate(self) -> Map {
        self.populate_randomly()
    }

    fn populate_randomly(mut self) -> Map {
        let mut rng = rand::thread_rng();
        let max_x = self.tiles.len();
        let max_y = self.tiles[0].len();

        for (y, row) in self.tiles.iter_mut().enumerate() {
            for (x, hex) in row.iter_mut().enumerate() {
                *hex = Map::generate_hex(&mut rng, x, y, max_x, max_y);
            }
        }
        self
    }

    fn smooth(&mut self) {
        let mut rng = rand::thread_rng();

        let max_y = self.tiles.len() - 1;
        let max_x = self.tiles[0].len() - 1;

        for y in 0..=max_y {
            for x in 0..=max_x {
                let op = rng.gen_range(0..100);
                if op < 45 {
                    // do nothing
                    continue;
                } else if op < 55 {
                    // transform the hex
                    self.tiles[y][x] = Hex {
                        hex_type: Map::transform_hex(self.tiles[y][x].hex_type, &mut rng),
                    }
                } else {
                    // determine tile's type by averaging the surroundings
                    let y_above = if y > 0 { y - 1 } else { max_y };
                    let y_below = if y < max_y { y + 1 } else { 0 };
                    let x_left = if x > 0 { x - 1 } else { max_x };
                    let x_right = if x < max_x { x + 1 } else { 0 };

                    let surrounding_types: [HexType; 8] = [
                        self.tiles[y_above][x_left].hex_type,
                        self.tiles[y_above][x].hex_type,
                        self.tiles[y_above][x_right].hex_type,
                        self.tiles[y][x_left].hex_type,
                        self.tiles[y][x_right].hex_type,
                        self.tiles[y_below][x_left].hex_type,
                        self.tiles[y_below][x].hex_type,
                        self.tiles[y_below][x_right].hex_type,
                    ];

                    let most_frequent_type = surrounding_types
                        .into_iter()
                        .fold(HashMap::<HexType, usize>::new(), |mut map, hex_type| {
                            *map.entry(hex_type).or_default() += 1;
                            map
                        })
                        .into_iter()
                        .max_by_key(|(_, cnt)| *cnt)
                        .map(|(k, _)| k)
                        .unwrap();
                    self.tiles[y][x] = Hex {
                        hex_type: most_frequent_type,
                    }
                }
            }
        }
    }

    fn transform_hex(hex_type: HexType, rng: &mut ThreadRng) -> HexType {
        let total_chance = HexType::total_transform_chance(hex_type);
        if total_chance == 0 {
            return hex_type;
        }

        let n = rng.gen_range(0..total_chance);
        let (_, ret) =
            HexType::iterator().fold((0, HexType::NONE), |(summed_percentage, ret), &t| {
                if summed_percentage > n {
                    (summed_percentage, ret)
                } else {
                    (summed_percentage + (t.transform_chance)(hex_type), t)
                }
            });
        ret
    }

    fn generate_hex(
        rng: &mut ThreadRng,
        _x: usize,
        _y: usize,
        _max_x: usize,
        _max_y: usize,
    ) -> Hex {
        //let equator_dist = (max_y / 2).abs_diff(y);
        //let pole_dist = min((0 as usize).abs_diff(y), max_y.abs_diff(y));
        let n = rng.gen_range(0..HexType::summed_terrain_base_chance());
        let (_, hex_type) =
            HexType::iterator().fold((0, HexType::NONE), |(summed_percentage, hex_type), &t| {
                if summed_percentage > n {
                    (summed_percentage, hex_type)
                } else {
                    (summed_percentage + t.base_chance, t)
                }
            });

        Hex { hex_type }
    }
}
